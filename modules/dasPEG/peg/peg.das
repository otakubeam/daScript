options indenting = 4
options no_unused_block_arguments = false
options no_unused_function_arguments = false
options no_aot = true
options strict_smart_pointers = true

module peg

require peg/parse_macro public
require strings public

def public matches(var parser; template_: string; strlen: int): bool
    var mark = parser.index

    // Not sufficient supply of charachters in the input
    return false if parser.input |> length < mark + strlen

    unsafe
        if memcmp(addr(parser.input[mark]), reinterpret<uint8?> template_, strlen) == 0
            parser.index += strlen
            return true

    return false


def public reached_EOF(var parser): bool
    return parser.input |> length <= parser.index


def public skip_whitespace(var parser)
    while parser |> get_current_char |> is_white_space
        parser.index += 1


// TODO: branch on UTF-8
def public get_current_char(var parser)
    return -1 if parser.input |> length <= parser.index
    return parser.input[parser.index] |> int()


// TODO: UTF-8
// var inscope get_current_char <- qmacro_function("get_current_char") <| $(var parser: $t(gen.parser_type))
//     return [[auto -1, 0]] if parser.input |> length <= parser.index
//     return decode_utf8_codepoint(parser.input, parser.index)
// var inscope peek_current_char <- qmacro_function("peek_current_char") <| $(var parser: $t(gen.parser_type))
//     return -1 if parser.input |> length <= parser.index
//     return decode_utf8_codepoint(parser.input, parser.index).res


def public match_decimal_literal(var parser): tuple<success:bool;value:int;endpos:int>
    //! Simple lexing of decimal integers, doesn't check for overflow

    if !parser |> get_current_char |> is_number
        // Can't use typedef in this context, sadly
        return [[tuple<success:bool;value:int;endpos:int>]]

    var result = 0

    while parser |> get_current_char |> is_number
        result *= 10
        result +=  parser |> get_current_char - '0'
        parser.index += 1

    return [[auto true, result, parser.index]]


def public match_string_literal(var parser): tuple<success:bool; string>
    //! Tries to match everything inside ""

    // Define buffer to store string literal characters
    var inscope buffer: array<uint8>

    var current_char = parser |> get_current_char

    // If the current character is not a double quote, the rule is not a string
    return [[auto false, ""]] if current_char != '"'

    parser.index += 1
    current_char = parser |> get_current_char

    while current_char != '"' && !parser |> reached_EOF
        buffer |> push(current_char |> uint8())
        parser.index += 1
        current_char = parser |> get_current_char

    // If we've reached EOF file without finding a closing quote
    return [[auto false, ""]] if parser |> reached_EOF

    parser.index += 1
    return [[auto true, buffer |> string()]]


def public match_double_literal(var parser): tuple<success:bool; double>
    //! Matches doubles in the form of [-+]? [0-9]* .? [0-9]+ ([eE] [-+]? [0-9]+)?
    //! The number is not checked to be representable as defined in IEEE-754

    var current_char = parser |> get_current_char

    if !current_char |> is_number && current_char != '+' && current_char != '-'
        return <- [[auto false, 0.0 |> double()]]

    var inscope buffer: array<uint8>

    if current_char == '-' || current_char == '+'
        buffer |> push(current_char |> uint8())
        parser.index += 1
        current_char = parser |> get_current_char

    // Add everything up to '.' to the buffer
    while current_char |> is_number || current_char == '.'
        buffer |> push(current_char |> uint8())
        parser.index += 1
        current_char = parser |> get_current_char


    // Match exponent part
    if current_char == 'e' || current_char == 'E'
        buffer |> push(current_char |> uint8())
        parser.index += 1
        current_char = parser |> get_current_char

        // Check for '-' or '+' after 'e' or 'E'
        if current_char == '-' || current_char == '+'
            buffer |> push(current_char |> uint8())
            parser.index += 1
            current_char = parser |> get_current_char

        // Continue appending digits after 'e' or 'E'
        while current_char |> is_number
            buffer |> push(current_char |> uint8())
            parser.index += 1
            current_char = parser |> get_current_char

    return [[auto true, buffer |> string() |> double()]]
